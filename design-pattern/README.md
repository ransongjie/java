# 创建型模式

## 简单工厂模式

- 作用：隐藏对象创建细节
- 例子：大众汽车工厂生产不同系列的汽车

## 抽象工厂模式

- 作用：隐藏对象创建细节
- 例子：建设大众汽车厂生产不同系列的大众汽车，建设保时捷汽车厂生产不同系列的保时捷

## 工厂方法模式（工厂模式）

- 作用：解耦对象创建与使用
- 例子：具体工厂A生产具体产品A，具体工厂B生产具体产品B

## 单例模式

- 作用：确保1个类只有1个实例
- 例子：饿汉式，懒汉式，枚举，DCL
- 例子：效率高使用hungry，有懒加载要求使用lazy，保证反序列化单例使用enums，有特殊要求使用dcl
- 实现：私有化构造器成员属性不提供setter、getter，向外提供访问接口，保证多线程单例、反序列化单例。枚举，需要单例的类由枚举类创建

## 建造者模式

- 作用：封装复杂对象的构建过程
- 例子：厨师做饭，建筑师造房子

## 原型模式

- 作用：更加高效的创建对象，复制现有对象来创建新对象
- 例子：拷贝复杂对象，需要长时间IO对象
- 实现：Cloneable 接口

# 结构型模式

## 适配器模式

- 作用：A类通过适配器使用B类的功能（重用已有的类，隔离变化）
- 例子：充电器转换头

## 装饰器模式

- 作用：增加功能而不使用继承
- 例子：功能流装饰节点流，形状增加颜色

## 代理模式

- 作用：增强类
- 例子：婚庆公司
- 实现：静态代理，JDK动态代理（接口），CGLIB动态代理（继承）

## 桥接模式

- 作用：用聚合代替继承

## 过滤器模式

- 作用：建立标准来过滤对象，标准之间通过逻辑运算解耦
- 例子：求值筛选

## 外观模式

- 类比与web界面，向用户提供简单接口，屏蔽内部复杂接口调用
- 创建外观类，提供调用子系统类的接口，

## 享元模式

- 作用：减少创建对象的数量，尽量利用已经创建的对象，以减少内存占用和提高性能

## 组合模式

- 作用：将对象组合成树状结构（叶子是基本类，临时根是组合类），使用整体或部分具有一致性
- 例子：awt/swing

# 行为型模式
## 命令模式
- 作用：解耦命令调用者与接受者，命令下达者/调用者→命令→命令执行者/接受者
- 例子：将军》开火》士兵 


# 对比

## 简单工厂模式 vs. 抽象工厂模式 vs. 工厂方法模式（工厂模式）

- 简单工厂模式，生产一种产品，违反开闭原则，增加新的产品时需要在简单工厂中添加创建此产品的逻辑
- 抽象工厂模式，可以生产工厂，违反开闭原则
- 工厂方法模式，产品的创建放到子工厂中，不违反开闭原则

## 简单工厂模式 vs. 建造者模式

- 后者构造过程更复杂
- 工厂模式主要关注对象的实例化过程和创建逻辑的封装
- 建造者模式主要关注复杂对象的构建过程和表示的分离

## 简单工厂模式 vs. 外观模式

- 工厂模式主要关注对象的实例化过程和创建逻辑的封装
- 外观模式主要关注简化客户端与子系统之间的交互

## 桥接模式 vs. 装饰器模式 vs. 代理模式

- 通过桥接来连接抽象和实现
- 通过包装对象来增强或变化其行为
- 通过代理对象来间接访问原对象提供额外的功能

## 原型模式 vs. 享元模式

- 通过复制现有对象来创建新对象
- 通过共享对象来减少内存使用和提高性能

# 总结

## 重要模式

- 工厂模式：细节隐藏
- 单例模式：单例
- 代理模式：代理增强
- 桥接模式：代替继承
- 装饰器模式：装饰增强
- 适配器模式：适配
- 过滤器模式：过滤
- 组合模式：组合树